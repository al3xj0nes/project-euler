using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace project_euler
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private void addToOutput(string msg)
        {
            txtOutputDisplay.AppendText(msg + "\r\n");
            txtOutputDisplay.ScrollToEnd();
        }

        private void btnRunSolution_Click(object sender, RoutedEventArgs e)
        {
            var watch = System.Diagnostics.Stopwatch.StartNew();
            // Increment selection made as combo box indexes from 0. Solutions index from 1.
            int selectionMade = comboSolutionSelection.SelectedIndex + 1;
            addToOutput("———————————————————————————————————————————————————————");
            if (comboSolutionSelection.SelectedIndex >= 0)
            {
                addToOutput("Loading solution for " + comboSolutionSelection.Text);
            }
            switch (selectionMade)
            {
                case 1:
                    projectEuler_Solution1();
                    break;
                case 2:
                    projectEuler_Solution2();
                    break;
                case 3:
                    projectEuler_Solution3();
                    break;
                case 4:
                    projectEuler_Solution4();
                    break;
                case 5:
                    projectEuler_Solution5();
                    break;
                case 6:
                    projectEuler_Solution6();
                    break;
                case 7:
                    projectEuler_Solution7();
                    break;
                case 8:
                    projectEuler_Solution8();
                    break;
                case 9:
                    projectEuler_Solution9();
                    break;
                default:
                    addToOutput("No implementation has been written for this function yet");
                    break;
            }
            watch.Stop();
            addToOutput("Time elapsed: " + watch.ElapsedMilliseconds + "ms");
        }

        private void projectEuler_Solution1()
        {
            /* If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
               The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. */
            addToOutput("If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.\r\n" +
                        "The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.\r\n");
            int totalSum = 0;
            for (int index = 0; index < 1000; index++)
            {
                if (index % 3 == 0 || index % 5 == 0)
                {
                    // This index value divides into 3 or 5 without a remainder, therefore is a mutliple of 3 or 5, add it to total.
                    totalSum += index;
                }
            }
            addToOutput("Total Sum = " + totalSum);
        }
        private void projectEuler_Solution2()
        {
            /* Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
                                                        1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
            By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms. */
            addToOutput("Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\r\n" +
                        "                                1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\r\n" +
                        "By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\r\n");
            int val1 = 1;
            int val2 = 2;
            int fibTest = 0;
            int sumEvenFibVals = 2; // Initialize with 2 as val2 (2) need to be added on initially.
            bool fourMilReached = false;
            while (!fourMilReached)
            {
                fibTest = val1 + val2;
                if (fibTest > 4000000)
                {
                    fourMilReached = true;
                }
                else
                {
                    val1 = val2;
                    val2 = fibTest;
                    if (fibTest % 2 == 0)
                    {
                        sumEvenFibVals += fibTest;
                        //addToOutput("SubTotal Sum = " + sumEvenFibVals + " by adding on " + fibTest);
                    }
                    else
                    {
                        //addToOutput("Skipped adding on " + fibTest + " as it's not even");
                    }
                }
            }
            addToOutput("Total Sum = " + sumEvenFibVals);
        }
        private void projectEuler_Solution3()
        {
            /* The prime factors of 13195 are 5, 7, 13 and 29.
               What is the largest prime factor of the number 600851475143 ? */
            addToOutput("The prime factors of 13195 are 5, 7, 13 and 29.\r\n" +
                        "What is the largest prime factor of the number 600851475143 ?\r\n");
            long valToInspect = 600851475143;
            long largestPrime = -1;
            for (long index = 1; index < Math.Sqrt(valToInspect);  index++)
            {
                // Is this index a factor of the value to inspect?
                if (valToInspect % index == 0)
                {
                    // addToOutput(index + " is a factor");
                    // Is this index a prime number?
                    if (math_isPrime(index) && index > largestPrime)
                    {
                        // addToOutput("... and is also a prime factor");
                        largestPrime = index;
                    }
                }
            }
            addToOutput("Largest prime of " + valToInspect + " = " + largestPrime);
        }
        private void projectEuler_Solution4()
        {
            /* A palindromic number reads the same both ways. The largest palindrome made from the product of two 2 - digit numbers is 9009 = 91 × 99.
               Find the largest palindrome made from the product of two 3 - digit numbers. */
            addToOutput("A palindromic number reads the same both ways. The largest palindrome made from the product of two 2 - digit numbers is 9009 = 91 × 99.\r\n" +
                        "Find the largest palindrome made from the product of two 3 - digit numbers.\r\n");

            // The palindrome lives between 100*100=10,000 and 999*999=998001 but can only be made using two 2-digit numbers multiplied.
            string strIndex = "";
            bool palindromeFound = false;
            int largestPalindrome = -1;
            
            for (int index_i = 100; index_i <= 999; index_i++)
            {
                for (int index_j = 100; index_j <= 999; index_j++)
                {
                    int result = index_i * index_j;
                    palindromeFound = true;
                    strIndex = result.ToString();
                    for (int index_chk = 0; index_chk <= (strIndex.Length / 2); index_chk++)
                    {
                        if (strIndex[index_chk] != strIndex[strIndex.Length - 1 - index_chk])
                        {
                            palindromeFound = false;
                        }
                    }
                    if (palindromeFound)
                    {
                        // addToOutput(result + " is a palindrome (" + index_i + "*" + index_j + ")");
                        if (result > largestPalindrome)
                        {
                            largestPalindrome = result;
                        }
                    }
                }
            }
            addToOutput("Largest palindrome = " + largestPalindrome);
        }
        private void projectEuler_Solution5()
        {
            /* 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
               What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20 ? */
            addToOutput("2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.\r\n" +
                        "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20 ?\r\n");
            int valueToInspect = 1;
            bool smallestValueFound = false;
            while (!smallestValueFound)
            {
                bool thisValueDivisible = true;
                for (int index = 1; index <= 20; index++)
                {
                    if (valueToInspect % index != 0)
                    {
                        thisValueDivisible = false;
                        break;
                    }
                }
                if (!thisValueDivisible)
                {
                    valueToInspect++;
                }
                else
                {
                    smallestValueFound = true;
                    addToOutput("The smallest value divisible by 1 through 10 = " + valueToInspect);
                }
            }
        }
        private void projectEuler_Solution6()
        {
            /* The sum of the squares of the first ten natural numbers is,
                        1^2 + 2^2 + ... + 10^2 = 385
               The square of the sum of the first ten natural numbers is,
                        (1 + 2 + ... + 10)^2 = 55^2 = 3025
               Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
               Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum. */
            addToOutput("The sum of the squares of the first ten natural numbers is,\r\n" +
                        "        1^2 + 2^2 + ... + 10^2 = 385\r\n" +
                        "The square of the sum of the first ten natural numbers is,\r\n" +
                        "        (1 + 2 + ... + 10)^2 = 55^2 = 3025\r\n" +
                        "Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.\r\n" +
                        "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.\r\n");
            double sumOfSquares = 0;
            double squareOfSums_preCalc = 0;
            double squareOfSums = 0;
            for (double index = 1; index <= 100; index++)
            {
                sumOfSquares += Math.Pow(index, 2);
                squareOfSums_preCalc += index;
            }
            squareOfSums = Math.Pow(squareOfSums_preCalc, 2);
            addToOutput("Sum of Squares = " + sumOfSquares);
            addToOutput("Square of Sums = " + squareOfSums);
            addToOutput("Difference between = " + Math.Abs(sumOfSquares - squareOfSums));
        }
        private void projectEuler_Solution7()
        {
            /* By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
               What is the 10 001st prime number? */
            addToOutput("By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.\r\n" +
                        "What is the 10 001st prime number ?\r\n");
            bool primeCalcComplete = false;
            double primeCalcVal = 2;
            int primeCalcIndex = 0;
            while (!primeCalcComplete)
            {
                if (math_isPrime(primeCalcVal))
                {
                    //addToOutput(primeCalcVal + " is a prime");
                    primeCalcIndex++;
                }
                if (primeCalcIndex == 10001)
                {
                    primeCalcComplete = true;
                }
                else {
                    primeCalcVal++;
                }
            }
            addToOutput("The 10,001st prime number = " + primeCalcVal);
        }
        private void projectEuler_Solution8()
        {
            /* The four adjacent digits in the 1000 - digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
                73167176531330624919225119674426574742355349194934
                96983520312774506326239578318016984801869478851843
                85861560789112949495459501737958331952853208805511
                12540698747158523863050715693290963295227443043557
                66896648950445244523161731856403098711121722383113
                62229893423380308135336276614282806444486645238749
                30358907296290491560440772390713810515859307960866
                70172427121883998797908792274921901699720888093776
                65727333001053367881220235421809751254540594752243
                52584907711670556013604839586446706324415722155397
                53697817977846174064955149290862569321978468622482
                83972241375657056057490261407972968652414535100474
                82166370484403199890008895243450658541227588666881
                16427171479924442928230863465674813919123162824586
                17866458359124566529476545682848912883142607690042
                24219022671055626321111109370544217506941658960408
                07198403850962455444362981230987879927244284909188
                84580156166097919133875499200524063689912560717606
                05886116467109405077541002256983155200055935729725
                71636269561882670428252483600823257530420752963450
                Find the thirteen adjacent digits in the 1000 - digit number that have the greatest product. What is the value of this product ? */
            addToOutput("The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.\r\n" +
                        "		73167176531330624919225119674426574742355349194934\r\n" +
                        "		96983520312774506326239578318016984801869478851843\r\n" +
                        "		85861560789112949495459501737958331952853208805511\r\n" +
                        "		12540698747158523863050715693290963295227443043557\r\n" +
                        "		66896648950445244523161731856403098711121722383113\r\n" +
                        "		62229893423380308135336276614282806444486645238749\r\n" +
                        "		30358907296290491560440772390713810515859307960866\r\n" +
                        "		70172427121883998797908792274921901699720888093776\r\n" +
                        "		65727333001053367881220235421809751254540594752243\r\n" +
                        "		52584907711670556013604839586446706324415722155397\r\n" +
                        "		53697817977846174064955149290862569321978468622482\r\n" +
                        "		83972241375657056057490261407972968652414535100474\r\n" +
                        "		82166370484403199890008895243450658541227588666881\r\n" +
                        "		16427171479924442928230863465674813919123162824586\r\n" +
                        "		17866458359124566529476545682848912883142607690042\r\n" +
                        "		24219022671055626321111109370544217506941658960408\r\n" +
                        "		07198403850962455444362981230987879927244284909188\r\n" +
                        "		84580156166097919133875499200524063689912560717606\r\n" +
                        "		05886116467109405077541002256983155200055935729725\r\n" +
                        "		71636269561882670428252483600823257530420752963450\r\n" +
                        "Find the thirteen adjacent digits in the 1000 - digit number that have the greatest product.What is the value of this product ?\r\n");
            string inputList = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450";
            int adjacentCount = 13;
            double largestProduct = -1;
            long testCalc = -1;
            string products = "";
            //addToOutput("String length = " + inputList.Length);
            for (int index = 0; index <= inputList.Length - adjacentCount; index++)
            {
                testCalc = 1;
                for (int sub_index = 0; sub_index < adjacentCount; sub_index++)
                {
                   // addToOutput(inputList.Substring(index, adjacentCount));
                    //addToOutput("[" + index + ":" + sub_index + "] = " + inputList[index + sub_index]);
                    testCalc *= Convert.ToInt64(inputList[index + sub_index].ToString());
                }
                if (testCalc > largestProduct)
                {
                    //addToOutput("New high found at index = " + index);
                    largestProduct = testCalc;
                    products = inputList.Substring(index, adjacentCount);
                }
            }
            addToOutput("Largest product = " + largestProduct + " from adjacent values " + products);

        }
        private void projectEuler_Solution9()
        {
            ;
        }

        /* Library functions that should be moved to a seperate file eventually */
        private bool math_isPrime(double n)
        {
            /* Based on solution in https://stackoverflow.com/questions/1801391/what-is-the-best-algorithm-for-checking-if-a-number-is-prime */
            if (n == 2 || n == 3)
            {
                return true;
            }
            else if (n % 2 == 0)
            {
                return false;
            }
            else if (n % 3 == 0)
            {
                return false;
            }
            else
            {
                int i = 5;
                int w = 2;
                while (Math.Pow(i, 2) <= n)
                {
                    if (n % i == 0)
                    {
                        return false;
                    }
                    i += w;
                    w = 6 - w;
                }
                return true;
            }
        }
    }
}