using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace project_euler
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private void addToOutput(string msg)
        {
            txtOutputDisplay.AppendText(msg + "\r\n");
            txtOutputDisplay.ScrollToEnd();
        }

        private void btnRunSolution_Click(object sender, RoutedEventArgs e)
        {
            var watch = System.Diagnostics.Stopwatch.StartNew();
            // Increment selection made as combo box indexes from 0. Solutions index from 1.
            int selectionMade = comboSolutionSelection.SelectedIndex + 1;
            addToOutput("———————————————————————————————————————————————————————");
            if (comboSolutionSelection.SelectedIndex >= 0)
            {
                addToOutput("Loading solution for " + comboSolutionSelection.Text);
            }
            switch (selectionMade)
            {
                case 1:
                    projectEuler_Solution1();
                    break;
                case 2:
                    projectEuler_Solution2();
                    break;
                case 3:
                    projectEuler_Solution3();
                    break;
                case 4:
                    projectEuler_Solution4();
                    break;
                default:
                    addToOutput("No implementation has been written for this function yet");
                    break;
            }
            watch.Stop();
            addToOutput("Time elapsed: " + watch.ElapsedMilliseconds + "ms");
        }

        private void projectEuler_Solution1()
        {
            /* If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
               The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. */
            addToOutput("If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.\r\n" +
                        "The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.\r\n");
            int totalSum = 0;
            for (int index = 0; index < 1000; index++)
            {
                if (index % 3 == 0 || index % 5 == 0)
                {
                    // This index value divides into 3 or 5 without a remainder, therefore is a mutliple of 3 or 5, add it to total.
                    totalSum += index;
                }
            }
            addToOutput("Total Sum = " + totalSum);
        }
        private void projectEuler_Solution2()
        {
            /* Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
                                                        1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
            By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms. */
            addToOutput("Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\r\n" +
                        "                                1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\r\n" +
                        "By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\r\n");
            int val1 = 1;
            int val2 = 2;
            int fibTest = 0;
            int sumEvenFibVals = 2; // Initialize with 2 as val2 (2) need to be added on initially.
            bool fourMilReached = false;
            while (!fourMilReached)
            {
                fibTest = val1 + val2;
                if (fibTest > 4000000)
                {
                    fourMilReached = true;
                }
                else
                {
                    val1 = val2;
                    val2 = fibTest;
                    if (fibTest % 2 == 0)
                    {
                        sumEvenFibVals += fibTest;
                        //addToOutput("SubTotal Sum = " + sumEvenFibVals + " by adding on " + fibTest);
                    }
                    else
                    {
                        //addToOutput("Skipped adding on " + fibTest + " as it's not even");
                    }
                }
            }
            addToOutput("Total Sum = " + sumEvenFibVals);
        }
        private void projectEuler_Solution3()
        {
            /* The prime factors of 13195 are 5, 7, 13 and 29.
               What is the largest prime factor of the number 600851475143 ? */
            addToOutput("The prime factors of 13195 are 5, 7, 13 and 29.\r\n" +
                        "What is the largest prime factor of the number 600851475143 ?\r\n");
            long valToInspect = 600851475143;
            long largestPrime = -1;
            for (long index = 1; index < Math.Sqrt(valToInspect);  index++)
            {
                // Is this index a factor of the value to inspect?
                if (valToInspect % index == 0)
                {
                    // addToOutput(index + " is a factor");
                    // Is this index a prime number?
                    if (math_isPrime(index) && index > largestPrime)
                    {
                        // addToOutput("... and is also a prime factor");
                        largestPrime = index;
                    }
                }
            }
            addToOutput("Largest prime of " + valToInspect + " = " + largestPrime);
        }
        private void projectEuler_Solution4()
        {
            /* A palindromic number reads the same both ways. The largest palindrome made from the product of two 2 - digit numbers is 9009 = 91 × 99.
               Find the largest palindrome made from the product of two 3 - digit numbers. */
            addToOutput("A palindromic number reads the same both ways. The largest palindrome made from the product of two 2 - digit numbers is 9009 = 91 × 99.\r\n" +
                        "Find the largest palindrome made from the product of two 3 - digit numbers.\r\n");

            // The palindrome lives between 100*100=10,000 and 999*999=998001 but can only be made using two 2-digit numbers multiplied.
            string strIndex = "";
            bool palindromeFound = false;
            int largestPalindrome = -1;
            
            for (int index_i = 100; index_i <= 999; index_i++)
            {
                for (int index_j = 100; index_j <= 999; index_j++)
                {
                    int result = index_i * index_j;
                    palindromeFound = true;
                    strIndex = result.ToString();
                    for (int index_chk = 0; index_chk <= (strIndex.Length / 2); index_chk++)
                    {
                        if (strIndex[index_chk] != strIndex[strIndex.Length - 1 - index_chk])
                        {
                            palindromeFound = false;
                        }
                    }
                    if (palindromeFound)
                    {
                        // addToOutput(result + " is a palindrome (" + index_i + "*" + index_j + ")");
                        if (result > largestPalindrome)
                        {
                            largestPalindrome = result;
                        }
                    }
                }
            }
            addToOutput("Largest palindrome = " + largestPalindrome);
        }

        private bool math_isPrime(long n)
        {
            // Return True is the value n is a prime number
            if (n <= 1)
            {
                // Negative values, zero, and 1 are not prime
                return false;
            }
            else
            {
                for (long index = 2; index < Math.Sqrt(n); index++)
                {
                    if (n % index == 0)
                    {
                        return false;
                    }
                }
                return true;
            }
        }
    }
}